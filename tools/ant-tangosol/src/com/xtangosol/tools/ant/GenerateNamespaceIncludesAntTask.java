/*
 * Copyright (c) 2000, 2023, Oracle and/or its affiliates.
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * https://oss.oracle.com/licenses/upl.
 */
package com.xtangosol.tools.ant;


import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;

import java.io.File;
import java.io.FilenameFilter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

import java.util.Arrays;
import java.util.Comparator;

/**
* Ant task that generates convenience C++ namespace include files.
* <br>
* <table>
*   <tr>
*     <td><b>Attribute</b></td>
*     <td><b>Description</b></td>
*     <td><b>Required</b></td>
*   </tr>
*   <tr>
*     <td>root</td>
*     <td>The root directory that contains one or more sub-directories that
*         each in turn contain all C++ include files for a corresponding C++
*         namespace. The namespace name is generated by appending the sub-
*         directory name to the root directory name and namespace separator
*         string ("::").</td>
*     <td>true</td>
*   </tr>
*   <tr>
*     <td>todir</td>
*     <td>Path to the directory in which the generated C++ include files will
*         be saved. If not specified, the include files will be generated
*         in place.</td>
*     <td>false</td>
*   </tr>
* </table>
*
* @author jh  2008.05.13
*/
public class GenerateNamespaceIncludesAntTask
        extends Task
    {
    // ----- constructors ---------------------------------------------------

    /**
    * Default constructor.
    */
    public GenerateNamespaceIncludesAntTask()
        {
        super();
        }


    // ----- Task methods ---------------------------------------------------

    /**
    * {@inheritDoc}
    */
    public void execute()
            throws BuildException
        {
        validateAttributes();
        execute(getRoot(), getToDir());
        }


    // ----- internal helpers -----------------------------------------------

    /**
    * Validate that all required attributes have been set to valid values.
    *
    * @throws BuildException if a required attribute is missing or has been
    *         set to an invalid value
    */
    protected void validateAttributes()
            throws BuildException
        {
        // validate root
        File fileRoot = getRoot();
        if (fileRoot == null)
            {
            throw new BuildException("Missing required 'root' attribute");
            }
        if (!fileRoot.exists())
            {
            throw new BuildException("The specified root directory '"
                    + fileRoot + "' does not exist");
            }
        if (!fileRoot.isDirectory())
            {
            throw new BuildException("The specified root directory '"
                    + fileRoot + "' is not a directory");
            }

        // validate todir
        if (getToDir() == null)
            {
            setToDir(fileRoot);
            }
        }

    /**
    * Generate a C++ namespace include file for each directory contained
    * within the specified directory that itself contains one or more
    * include files. The namespace include file will be named after the
    * source directory name.
    *
    * @param fileRoot   the source directory
    * @param fileToDir  the destination directory
    */
    protected void execute(File fileRoot, File fileToDir)
        {
        assert fileRoot  != null;
        assert fileToDir != null;

        // make sure the specified directory is accessible
        if (fileToDir.exists())
            {
            if (!fileToDir.isDirectory())
                {
                throw new BuildException(
                        "The specified destination directory '"
                        + fileToDir
                        + "' is not a directory");
                }
            }
        else if (!fileToDir.mkdirs())
            {
            throw new BuildException("The destination directory '"
                    + fileToDir + "' could not be created");
            }

        // scan for child directories with header files
        File[] aFile = fileRoot.listFiles();
        for (int i = 0, c = aFile == null ? 0 : aFile.length; i < c; ++i)
            {
            File file = aFile[i];
            if (file.isDirectory())
                {
                // generate namespace include for the child directory
                File[] aFileHpp = file.listFiles(HPP_FILENAME_FILTER);
                if (aFileHpp != null && aFileHpp.length > 0)
                    {
                    generate(file.getName(), fileToDir, aFileHpp);
                    }

                // decend
                execute(file, new File(fileToDir, file.getName()));
                }
            }
        }

    /**
    * Generate a C++ namespace include file for the specified namespace in
    * the specified directory that includes the specified files
    *
    * @param sName         the name of the namespace
    * @param fileToDir     the destination directory
    * @param aFileInclude  the list of files to include
    */
    protected void generate(String sName, File fileToDir, File[] aFileInclude)
        {
        assert sName        != null;
        assert fileToDir    != null;
        assert aFileInclude != null;

        // create the namespace include file
        File file = new File(fileToDir, sName + ".ns");
        try
            {
            file.createNewFile();
            }
        catch (IOException e)
            {
            throw new BuildException("Error creating namespace include file '"
                    + file + "'", e);
            }
        log("Generating namespace include file '" + file + "'");

        // compute the fully qualified namespace and include prefix
        StringBuffer sbNamespace     = new StringBuffer(sName);
        StringBuffer sbIncludePrefix = new StringBuffer(sName + "/");
        File         fileNamespace   = fileToDir;
        File         fileRoot        = getToDir();
        do
            {
            String sParent = fileNamespace.getName();
            sbNamespace.insert(0, "::");
            sbNamespace.insert(0, sParent);
            sbIncludePrefix.insert(0, '/');
            sbIncludePrefix.insert(0, sParent);

            fileNamespace = fileNamespace.getParentFile();
            }
        while (fileNamespace != null && !fileNamespace.equals(fileRoot));

        // generate the namespace include file
        PrintWriter writer;
        try
            {
            writer = new PrintWriter(new FileWriter(file));
            }
        catch (IOException e)
            {
            throw new BuildException("Error opening namespace include file", e);
            }
        try
            {
            // output banner
            writer.println("/*");
            writer.print("* ");
            writer.print(file.getName());
            writer.println(" is a convenience file which allows for easy inclusion of all");
            writer.print("* files from the ");
            writer.print(sbNamespace.toString());
            writer.println(" namespace.");
            writer.println("*");
            writer.print("* It is recommended that any file which includes ");
            writer.print(file.getName());
            writer.println(" also contains");
            writer.print("* an explicit \"using namespace ");
            writer.print(sbNamespace.toString());
            writer.println("\" within its own namespace.");
            writer.println("*/");
            writer.println();

            // open header guard
            String sGuard = "COH_" + sName.toUpperCase() + "_NS";
            writer.print("#ifndef ");
            writer.println(sGuard);
            writer.print("#define ");
            writer.println(sGuard);
            writer.println();

            // include all files
            Arrays.sort(aFileInclude, Comparator.comparing(File::getName));
            for (int i = 0, c = aFileInclude.length; i < c; ++i)
                {
                String sFileName = aFileInclude[i].getName();
                if (sFileName.equals(NAMESPACE_HPP))
                    {
                    continue;
                    }
                writer.print("#include \"");
                writer.print(sbIncludePrefix.toString());
                writer.print(sFileName);
                writer.println('"');
                }
            writer.println();

            // close header guard
            writer.print("#endif // ");
            writer.println(sGuard);

            writer.flush();
            }
        finally
            {
            writer.close();
            }
        }


    // ----- accessors ------------------------------------------------------

    /**
    * Return the directory that contains or more directories with include
    * files.
    *
    * @return the include root directory
    */
    public File getRoot()
        {
        return m_fileRoot;
        }

    /**
    * Configure the the directory that contains or more directories with
    * include files.
    *
    * @param fileRoot  the include root directory
    */
    public void setRoot(File fileRoot)
        {
        m_fileRoot = fileRoot;
        }

    /**
    * Return the optional destination directory for generated header files.
    *
    * @return the destination directory
    */
    public File getToDir()
        {
        return m_fileToDir;
        }

    /**
    * Configure the destination directory for generated header files.
    *
    * @param fileToDir  the destination directory
    */
    public void setToDir(File fileToDir)
        {
        m_fileToDir = fileToDir;
        }


    // ----- data members ---------------------------------------------------

    /**
    * The directory that contains one or more directories with include files.
    */
    private File m_fileRoot;

    /**
    * The optinal destination directory.
    */
    private File m_fileToDir;


    // ----- constants ------------------------------------------------------

    /**
    * FilenameFilter that accepts all .hpp files.
    */
    public static final FilenameFilter HPP_FILENAME_FILTER
            = new FilenameFilter()
        {
        /**
        * {@inheritDoc}
        */
        public boolean accept(File dir, String name)
            {
            return name.length() > 4 &&
                    name.substring(name.length() - 4).equalsIgnoreCase(".hpp");
            }
        };

    /**
    * The name of the .hpp files that contain a description of a namespace.
    */
    public static final String NAMESPACE_HPP = "namespace.hpp";
    }
